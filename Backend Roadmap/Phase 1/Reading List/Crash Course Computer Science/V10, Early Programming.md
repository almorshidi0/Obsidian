This episode explores the history of how programs are loaded into computers, from early mechanical devices to modern electronic memory. It covers concepts like punched cards, plug boards, panel programming, and stored-program computers, explaining how these methods enabled computers to become more versatile and efficient.

## üßµ Early Programming: Before Computers
*   The need to program machines existed before computers, notably in **textile manufacturing**.
*   **Jacquard's loom** (1801) was one of the earliest forms of programming.
*   The loom used **punched cards** to define patterns in cloth.
    * The presence or absence of a hole determined if a thread was high or low.
    * The cards were arranged in chains, forming a sequence of commands for the loom.
*   Punched cards were a cheap and reliable way to store data, and were somewhat human-readable.

## üìä Punched Cards
*   Punched cards were used to **tabulate the 1890 census**.
    * Each card held an individual person's data.
    * A hole would increase the running total for a specific answer.
*   Early tabulating machines were **not truly computers** because their operations were fixed and not programmable.
*   Punched cards stored data, not programs.
*   Punched cards were used to load data into computers well into the 1980s.
*   A stack of cards could represent a program, with the reader loading them sequentially into memory.
*   Large programs could be stored on **stacks of cards**, which were cumbersome and easy to drop.
    *   A common trick was to draw a diagonal line on the card stack called **striping**, to help put the cards back in order.
*   The US Air Force's SAGE air defense system, completed in 1955, used a main control program stored on **62,500 punch cards**, equivalent to roughly 5 megabytes of data.
*  Punched cards could also be used to **get data out of computers**, to be analyzed by humans or loaded into a second program.
*   **Punched paper tape** is similar to punched cards, but continuous.

## üîå Plug Boards
*   Business machines grew to perform more operations, including subtraction, multiplication, division, and simple decisions.
*   To perform these different calculations, **programmers used a control panel** full of sockets into which cables were plugged.
*   These control panels were also called **plug boards**.
*   Plug boards were swappable, allowing different programs to be run.
*   Plug boards were very complex, and rewiring the machine for different programs was time-consuming.
*   The **Eniac**, the first general-purpose electronic computer, used plug boards, and wiring a program could take weeks.

## üíæ Stored-Program Computers
*   By the late 1940s and 50s, **electronic memory** became feasible.
*   Programs could be stored entirely in a computer's memory, which could be easily changed by programmers and accessed by the CPU.
*   These were called **stored-program computers**.
*   The **von Neumann architecture** unifies programming data into a single shared memory.
    *   Key components include a processing unit (ALU, data registers, instruction register, and instruction address register) and memory for data and instructions.
    *   The first von Neumann architecture stored-program computer was constructed in 1948, nicknamed "Baby".
    *   The computer you're using right now uses the same architecture.

## üïπÔ∏è Panel Programming
*   Panel programming involved using **switches and buttons** instead of cables to activate functions.
*   **Indicator lights** displayed the status of various functions and values in memory.
*   Early computers had huge control consoles with switches, although it was rare to input a whole program this way.
*   Early home computers, like the **Altair 8800**, used switches extensively because they were cheaper than card readers.
    *   To program the Altair, you toggled switches for binary opcodes, then pressed deposit to write the value to memory.
*   You would then move to the next memory address, repeat, and once the program was entered, move back to address zero and press "run".

## üë®‚Äçüíª Programming Challenges
*   Programming early computers required intimate knowledge of the hardware, like processor opcodes.
*   Programming was hard and tedious, and even professional engineers struggled.
*  A simpler way to tell computers what to do was needed.

## ‚è≠Ô∏è Next Steps
*   The next episode will discuss programming languages.

This episode shows the progression of how programs were loaded into early computers, from mechanical looms and punched cards to plug boards and eventually, stored-program computers. It underscores the complexity of early programming methods and the need for more accessible and efficient techniques.
